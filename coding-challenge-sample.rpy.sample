init python:
    import threading
    import queue
    import time

    try:
        from pygments import highlight
        from pygments.lexers import get_lexer_by_name, guess_lexer
        from pygments.formatters import get_formatter_by_name
        from pygments.util import ClassNotFound
        PYGMENTS_AVAILABLE = True
    except ImportError:
        PYGMENTS_AVAILABLE = False
        raise Exception("Pygments not available.")
        print("Pygments not available - falling back to plain text")
    
    # Custom Ren'Py formatter for Pygments
    class RenpyFormatter:
        """Converts Pygments tokens to Ren'Py Text objects with colors"""
        
        # VS Code Dark+ theme colors
        TOKEN_COLORS = {
            'Keyword': '#569cd6',           # Blue
            'Keyword.Constant': '#569cd6',
            'Keyword.Declaration': '#569cd6',
            'Keyword.Namespace': '#569cd6',
            'Keyword.Pseudo': '#569cd6',
            'Keyword.Reserved': '#569cd6',
            'Keyword.Type': '#4ec9b0',      # Cyan
            
            'String': '#ce9178',            # Orange
            'String.Char': '#ce9178',
            'String.Doc': '#6a9955',        # Green (docstrings)
            'String.Double': '#ce9178',
            'String.Single': '#ce9178',
            'String.Escape': '#d7ba7d',     # Light orange
            
            'Comment': '#6a9955',           # Green
            'Comment.Multiline': '#6a9955',
            'Comment.Single': '#6a9955',
            'Comment.Special': '#6a9955',
            
            'Number': '#b5cea8',            # Light green
            'Number.Float': '#b5cea8',
            'Number.Integer': '#b5cea8',
            'Number.Hex': '#b5cea8',
            
            'Name.Function': '#dcdcaa',     # Yellow
            'Name.Class': '#4ec9b0',        # Cyan
            'Name.Variable': '#9cdcfe',     # Light blue
            'Name.Builtin': '#569cd6',      # Blue
            'Name.Exception': '#4ec9b0',    # Cyan
            
            'Operator': '#d4d4d4',          # White
            'Punctuation': '#d4d4d4',       # White
            
            'Text': '#d4d4d4',              # Light gray (default)
        }
        
        def format_tokens(self, tokens):
            """Convert pygments tokens to Ren'Py displayables"""
            lines = [[]]  # Start with first line
            
            for token_type, value in tokens:
                # Handle newlines by splitting into separate lines
                if '\n' in value:
                    parts = value.split('\n')
                    # Add first part to current line
                    if parts[0]:
                        color = self.get_token_color(token_type)
                        lines[-1].append(Text(parts[0], color=color, font="DejaVuSansMono.ttf", size=11))
                    
                    # Create new lines for middle parts
                    for part in parts[1:-1]:
                        lines.append([])  # New line
                        if part:
                            color = self.get_token_color(token_type)
                            lines[-1].append(Text(part, color=color, font="DejaVuSansMono.ttf", size=11))
                    
                    # Start new line for last part
                    if len(parts) > 1:
                        lines.append([])
                        if parts[-1]:
                            color = self.get_token_color(token_type)
                            lines[-1].append(Text(parts[-1], color=color, font="DejaVuSansMono.ttf", size=11))
                else:
                    # Add to current line
                    if value:
                        color = self.get_token_color(token_type)
                        lines[-1].append(Text(value, color=color, font="DejaVuSansMono.ttf", size=11))
            
            # Convert lines to Ren'Py displayables
            line_displayables = []
            for line_parts in lines:
                if not line_parts:
                    # Empty line
                    line_displayables.append(Text(" ", font="DejaVuSansMono.ttf", size=11))
                elif len(line_parts) == 1:
                    # Single part line
                    line_displayables.append(line_parts[0])
                else:
                    # Multiple parts - use HBox
                    line_displayables.append(HBox(*line_parts))
            
            return VBox(*line_displayables, spacing=2)
        
        def get_token_color(self, token_type):
            """Get color for a token type"""
            token_name = str(token_type)
            
            # Try exact match first
            if token_name in self.TOKEN_COLORS:
                return self.TOKEN_COLORS[token_name]
            
            # Try parent types
            parts = token_name.split('.')
            for i in range(len(parts) - 1, 0, -1):
                parent_type = '.'.join(parts[:i])
                if parent_type in self.TOKEN_COLORS:
                    return self.TOKEN_COLORS[parent_type]
            
            # Default color
            return self.TOKEN_COLORS['Text']
    
    def highlight_code(code, language):
        """Apply syntax highlighting using Pygments"""
        if not PYGMENTS_AVAILABLE:
            return Text(code, color="#d4d4d4", font="DejaVuSansMono.ttf", size=11)
        
        try:
            lexer = get_lexer_by_name(language)
            
            # Tokenize the code
            tokens = list(lexer.get_tokens(code))
            
            # Format tokens for Ren'Py
            formatter = RenpyFormatter()
            return formatter.format_tokens(tokens)
            
        except ClassNotFound:
            # Fallback if language not supported
            return Text(code, color="#d4d4d4", font="DejaVuSansMono.ttf", size=11)
        except Exception as e:
            print(f"Highlighting error: {e}")
            return Text(code, color="#d4d4d4", font="DejaVuSansMono.ttf", size=11)
    
    class SequentialChallengeBuffer:
        def __init__(language, topic):
            self.buffer = queue.Queue(maxsize=3)
            self.loading = False
            self.worker_thread = None
            self.language = language
            self.topics = topic
            self.start_worker()
        
        def start_worker(self):
            def worker():
                while True:
                    try:
                        if not self.buffer.full() and not self.loading:
                            self.loading = True
                            challenge = self.generate_challenge()
                            self.buffer.put(challenge)
                            self.loading = False
                        

                        time.sleep(1)
                        
                    except Exception as e:
                        self.loading = False
                        print(f"Challenge generation error: {e}")
            
            self.worker_thread = threading.Thread(target=worker)
            self.worker_thread.daemon = True
            self.worker_thread.start()
        
        def generate_challenge(self):
            language self.language
            topic = self.topics
            
            correct_prompt = f"Generate clean, well-commented {language} code for {topic}. Make it production-ready with proper error handling."
            buggy_prompt = f"Generate {language} code for {topic} with a subtle but critical bug like null pointer dereference, buffer overflow, memory leak, or off-by-one error."
            
            try:
                correct_code = call_gemini(correct_prompt)
                buggy_code = call_gemini(buggy_prompt)
                
                return {
                    "language": language,
                    "topic": topic,
                    "correct_code": correct_code,
                    "buggy_code": buggy_code,
                    "prompt": f"Which {language} code correctly implements {topic}?",
                    "filename": f"{topic.replace(' ', '_')}.{self.get_file_extension(language)}"
                }
            except:
                return self.get_fallback_challenge(language, topic)
        
        def get_file_extension(self, language):
            extensions = {
                "python": "py", "cpp": "cpp", "javascript": "js", 
                "java": "java", "rust": "rs"
            }
            return extensions.get(language, "txt")
        
        def get_fallback_challenge(self, language, topic):
            fallbacks = {
                "python": {
                    "correct": '''def quicksort(arr):
    """Correct quicksort implementation"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]  
    right = [x for x in arr if x > pivot]
    
    return quicksort(left) + middle + quicksort(right)

# Test the function
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_nums = quicksort(numbers)
print(f"Sorted: {sorted_nums}")''',
                    "buggy": '''def quicksort(arr):
    """Buggy quicksort - infinite recursion possible"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[0]  # Poor pivot choice
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    # BUG: Missing base case handling for duplicates
    return quicksort(left) + middle + quicksort(right)'''
                },
                "cpp": {
                    "correct": '''#include <vector>
#include <iostream>

class SafeArray {
private:
    std::vector<int> data;
    
public:
    SafeArray(size_t size) : data(size) {}
    
    int& at(size_t index) {
        if (index >= data.size()) {
            throw std::out_of_range("Index out of bounds");
        }
        return data[index];
    }
    
    size_t size() const { return data.size(); }
};''',
                    "buggy": '''#include <iostream>

class UnsafeArray {
private:
    int* data;
    size_t length;
    
public:
    UnsafeArray(size_t size) : length(size) {
        data = new int[size];
        // BUG: No initialization of array elements
    }
    
    int& at(size_t index) {
        // BUG: No bounds checking!
        return data[index];
    }
    
    // BUG: No destructor - memory leak!
};'''
                }
            }
            
            lang_fallback = fallbacks.get(language, fallbacks["python"])
            return {
                "language": language,
                "topic": topic,
                "correct_code": lang_fallback["correct"],
                "buggy_code": lang_fallback["buggy"], 
                "prompt": f"Which {language} code correctly implements {topic}?",
                "filename": f"example.{self.get_file_extension(language)}"
            }
        
        def get_next_challenge(self):
            try:
                return self.buffer.get_nowait()
            except queue.Empty:
                return self.generate_challenge()
    
    challenge_system = SequentialChallengeBuffer()
    coding_streak = 0
    total_challenges = 0
    correct_answers = 0

# Screen with Pygments syntax highlighting (FIXED)
# Screen with Pygments syntax highlighting (FULLY FIXED)
screen pygments_challenge_screen(challenge):
    modal True
    
    # Calculate colors based on language and accuracy
    python:
        # Language background color
        if challenge["language"] == "python":
            lang_bg_color = "#3776ab"
        elif challenge["language"] == "rust":
            lang_bg_color = "#ce422b"
        elif challenge["language"] == "javascript":
            lang_bg_color = "#f7df1e"
        elif challenge["language"] == "java":
            lang_bg_color = "#ed8b00"
        elif challenge["language"] == "cpp":
            lang_bg_color = "#00599c"
        else:
            lang_bg_color = "#1f6feb"
        
        # Accuracy color
        if total_challenges > 0:
            accuracy = (correct_answers * 100.0 / total_challenges)
            if accuracy < 50:
                accuracy_color = "#f85149"  # Red
            elif accuracy < 75:
                accuracy_color = "#f0883e"  # Orange
            else:
                accuracy_color = "#2ea043"  # Green
        else:
            accuracy_color = "#7d8590"  # Gray
    
    frame:
        background "#0d1117"  # GitHub dark theme
        xsize 1200
        ysize 750
        xalign 0.5
        yalign 0.5
        
        vbox:
            spacing 8
            
            # Header with language badge
            frame:
                background "#21262d"
                xfill True
                ysize 55
                
                hbox:
                    spacing 15
                    
                    # Language badge with dynamic color
                    frame:
                        background lang_bg_color
                        padding (15, 8)
                        text challenge["language"].upper():
                            color "#ffffff"
                            size 14
                            bold True
                    
                    # Topic and filename
                    vbox:
                        spacing 2
                        yalign 0.5
                        
                        text challenge["topic"].title():
                            color "#f0f6fc"
                            size 18
                            
                        text challenge["filename"]:
                            color "#7d8590"
                            size 12
                    
                    # Buffer status
                    text "Buffer: [challenge_system.buffer.qsize()]/3":
                        color "#58a6ff"
                        size 12
                        xalign 1.0
                        yalign 0.5
            
            # Challenge prompt
            frame:
                background "#161b22"
                xfill True
                ysize 50
                
                text challenge["prompt"]:
                    color "#e6edf3"
                    size 18
                    xalign 0.5
                    yalign 0.5
            
            # Code comparison with syntax highlighting
            hbox:
                spacing 10
                
                # Option A
                vbox:
                    spacing 5
                    xsize 590
                    
                    # Choose button
                    textbutton "✓ Choose Code A":
                        action Return("option_a")
                        background "#238636"
                        hover_background "#2ea043"
                        text_color "#ffffff"
                        text_size 16
                        xfill True
                        ysize 40
                    
                    # Code display with syntax highlighting
                    frame:
                        background "#0d1117"
                        xsize 590
                        ysize 580
                        
                        viewport:
                            scrollbars "vertical"
                            mousewheel True
                            
                            frame:
                                background "#161b22"
                                padding (15, 15)
                                xfill True
                                
                                # Apply Pygments syntax highlighting
                                add highlight_code(challenge["correct_code"], challenge["language"])
                
                # Option B
                vbox:
                    spacing 5
                    xsize 590
                    
                    # Choose button
                    textbutton "✓ Choose Code B":
                        action Return("option_b")
                        background "#da3633"
                        hover_background "#f85149"
                        text_color "#ffffff"
                        text_size 16
                        xfill True
                        ysize 40
                    
                    # Code display with syntax highlighting
                    frame:
                        background "#0d1117"
                        xsize 590
                        ysize 580
                        
                        viewport:
                            scrollbars "vertical"
                            mousewheel True
                            
                            frame:
                                background "#161b22"
                                padding (15, 15)
                                xfill True
                                
                                # Apply Pygments syntax highlighting
                                add highlight_code(challenge["buggy_code"], challenge["language"])
            
            # Footer with stats
            frame:
                background "#21262d"
                xfill True
                ysize 35
                
                hbox:
                    spacing 20
                    yalign 0.5
                    
                    text "Streak: [coding_streak]":
                        color "#2ea043"
                        size 14
                        
                    text "Score: [correct_answers]/[total_challenges]":
                        color "#58a6ff"
                        size 14
                        
                    # Only show accuracy if we have attempts
                    if total_challenges > 0:
                        text "Accuracy: [accuracy:.1f]%":
                            color accuracy_color
                            size 14
                    
                    textbutton "Skip Challenge":
                        action Return("skip")
                        text_color "#7d8590"
                        text_size 12
                        xalign 1.0



# # Main challenge flow
# label start_challenge_sequence:
    
#     st "Ready for some syntax-highlighted coding challenges?"
#     sp "Bzzt! Multiple language with proper coloring! ⚡"
    
#     $ total_challenges = 0
#     $ correct_answers = 0
#     $ coding_streak = 0
    
#     jump next_challenge

# label next_challenge:
#     $ current_challenge = challenge_system.get_next_challenge()
#     $ total_challenges += 1
    
#     st "Challenge [total_challenges]: [current_challenge['language'].title()]!"
#     sp "Topic: [current_challenge['topic'].title()]! ⚡"
    
#     call screen pygments_challenge_screen(current_challenge)
    
#     jump evaluate_response

# label evaluate_response:
#     $ player_choice = _return
#     $ correct_option = "option_a" if renpy.random.random() > 0.5 else "option_b"
#     $ is_correct = (player_choice == correct_option)
    
#     if is_correct:
#         $ correct_answers += 1
#         $ coding_streak += 1
        
#         if coding_streak <= 3:
#             st "Perfect! That's [coding_streak] in a row!"
#         else:
#             sp "AMAZING! [coding_streak] streak! You're on fire! ⚡⚡⚡"
#     else:
#         $ coding_streak = 0
#         st "Not quite! The answer was [correct_option.replace('_', ' ').title()]."
#         sp "The bug was in the [current_challenge['language']] [current_challenge['topic']] implementation!"
    
#     menu:
#         "Next challenge!" if total_challenges < 15:
#             jump next_challenge
            
#         "Show my stats":
#             $ accuracy = (correct_answers * 100.0 / total_challenges) if total_challenges > 0 else 0
#             "Stats: [correct_answers]/[total_challenges] correct ([accuracy:.1f]%)"
#             "Current streak: [coding_streak]"
#             jump next_challenge
            
#         "End challenge session":
#             jump end_sequence

# label end_sequence:
#     $ final_accuracy = (correct_answers * 100.0 / total_challenges) if total_challenges > 0 else 0
    
#     st "Great session! Final score: [correct_answers]/[total_challenges] ([final_accuracy:.1f]%)"
    
#     if coding_streak >= 5:
#         sp "That final streak of [coding_streak] was electrifying! ⚡"
    
#     return
